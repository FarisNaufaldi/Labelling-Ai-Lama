// MessageInput.tsx
import { useState, useRef, useEffect, useMemo, useLayoutEffect } from "react";
import { useMessaging } from "../../hooks/useMessaging";
import { useRealtimeAISuggestion } from "../../hooks/useRealtimeAISuggestion";
import { Button } from "../ui/Button";
import { Loader2, SendHorizontal } from "lucide-react";
import type { MessageSource } from "./MessageSourceBadge";
import DefaultButtonIcon from "./icons/DefaultButton.svg?react";
import { normalizeText, calcSimilarity } from "../../lib/textSimilarity";

// AI Sparkles Icon
const AISparklesIcon = ({ className }: { className?: string }) => (
  <svg
    width="16"
    height="16"
    viewBox="0 0 16 16"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    className={className}
  >
    <path
      d="M7.59339 0.791379C7.76344 0.460412 8.23656 0.460412 8.40661 0.791379L10.6482 5.15412C10.6918 5.23904 10.761 5.30817 10.8459 5.35181L15.2086 7.59339C15.5396 7.76344 15.5396 8.23656 15.2086 8.40661L10.8459 10.6482C10.761 10.6918 10.6918 10.761 10.6482 10.8459L8.40661 15.2086C8.23656 15.5396 7.76344 15.5396 7.59339 15.2086L5.35181 10.8459C5.30817 10.761 5.23904 10.6918 5.15412 10.6482L0.791379 8.40661C0.460412 7.76344 0.460412 7.76344 0.791379 7.59339L5.15412 5.35181C5.23904 5.30817 5.30817 5.23904 5.35181 5.15412L7.59339 0.791379Z"
      fill="currentColor"
    />
  </svg>
);

interface MessageInputProps {
  conversationId: string;
}

type TooltipAnimState = "hidden" | "moving-up" | "visible" | "moving-down";

export const MessageInput = ({ conversationId }: MessageInputProps) => {
  const {
    currentDraft,
    setDraft,
    sendMessage,
    isSendingMessage,
    conversations,
  } = useMessaging();

  const textareaRef = useRef<HTMLTextAreaElement | null>(null);
  const composerRef = useRef<HTMLDivElement | null>(null);

  const labelRef = useRef<HTMLSpanElement | null>(null);
  const labelWrapRef = useRef<HTMLDivElement | null>(null);

  const [localValue, setLocalValue] = useState(currentDraft);
  const [userHasEdited, setUserHasEdited] = useState(false);

  const [showNoAITooltip, setShowNoAITooltip] = useState(false);
  const [tooltipAnimationState, setTooltipAnimationState] =
    useState<TooltipAnimState>("hidden");

  const [forceNoAI, setForceNoAI] = useState(false);

  const lastSuggestionIdRef = useRef<string | null>(null);
  const lastSentSuggestionIdRef = useRef<string | null>(null);

  // Flag to prevent auto-populating after any send (AI, edited, or user)
  const justSentMessageRef = useRef(false);

  const conversation = conversations.find((c) => c.id === conversationId);
  const { suggestion: aiSuggestion } = useRealtimeAISuggestion(conversationId);

  // Keep messages container aligned above composer height (CSS var on scroll container)
  useLayoutEffect(() => {
    const el = composerRef.current;
    if (!el) return;

    const scrollParent = el.closest<HTMLElement>("[data-thread-scroll='true']");
    if (!scrollParent) return;

    const setVar = () => {
      const h = Math.ceil(el.getBoundingClientRect().height || 0);
      scrollParent.style.setProperty("--composer-height", `${h}px`);
    };

    setVar();

    let ro: ResizeObserver | null = null;
    if (typeof ResizeObserver !== "undefined") {
      ro = new ResizeObserver(() => setVar());
      ro.observe(el);
    }

    window.addEventListener("resize", setVar);
    return () => {
      window.removeEventListener("resize", setVar);
      ro?.disconnect();
    };
  }, []);

  // Auto-resize textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
      textareaRef.current.style.height = `${Math.min(
        textareaRef.current.scrollHeight,
        150
      )}px`;
    }
  }, [localValue]);

  // Determine if we're showing AI content (not edited)
  const isShowingAISuggestion =
    !!aiSuggestion?.suggestion &&
    !forceNoAI &&
    !userHasEdited &&
    normalizeText(localValue) === normalizeText(aiSuggestion.suggestion);

  // Apply new AI suggestion (but prevent echo right after sending)
  useEffect(() => {
    if (
      aiSuggestion?.suggestion &&
      aiSuggestion.id !== lastSuggestionIdRef.current
    ) {
      if (justSentMessageRef.current) {
        justSentMessageRef.current = false;
        lastSuggestionIdRef.current = aiSuggestion.id;
        return;
      }

      lastSuggestionIdRef.current = aiSuggestion.id;
      setLocalValue(aiSuggestion.suggestion);
      setDraft(conversationId, aiSuggestion.suggestion);
      setUserHasEdited(false);

      // Only clear forceNoAI if this is a truly new suggestion (not the one just sent)
      if (aiSuggestion.id !== lastSentSuggestionIdRef.current) {
        setForceNoAI(false);
      }
    }
  }, [aiSuggestion, conversationId, setDraft]);

  // Reset state when switching conversation
  useEffect(() => {
    setLocalValue("");
    setDraft(conversationId, "");
    setUserHasEdited(false);
    lastSuggestionIdRef.current = null;
    lastSentSuggestionIdRef.current = null;
    justSentMessageRef.current = false;
    setForceNoAI(false);
    setShowNoAITooltip(false);
    setTooltipAnimationState("hidden");
  }, [conversationId, setDraft]);

  // Tooltip animation lifecycle
  useEffect(() => {
    if (showNoAITooltip) {
      setTooltipAnimationState("hidden");

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          setTooltipAnimationState("moving-up");
        });
      });

      const visibleTimer = setTimeout(() => {
        setTooltipAnimationState("visible");
      }, 500);

      const moveDownTimer = setTimeout(() => {
        setTooltipAnimationState("moving-down");
      }, 4500);

      const hideTimer = setTimeout(() => {
        setTooltipAnimationState("hidden");
        setShowNoAITooltip(false);
      }, 5000);

      return () => {
        clearTimeout(visibleTimer);
        clearTimeout(moveDownTimer);
        clearTimeout(hideTimer);
      };
    }
  }, [showNoAITooltip]);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;

    // Treat suggestion as inactive when forceNoAI=true
    const originalSuggestion =
      !forceNoAI && aiSuggestion?.suggestion ? aiSuggestion.suggestion : "";

    // If no active AI suggestion, always behave like a pure user draft
    if (!originalSuggestion) {
      setUserHasEdited(false);
      setLocalValue(value);
      setDraft(conversationId, value);
      return;
    }

    const matchesOriginalAI =
      normalizeText(value) === normalizeText(originalSuggestion);

    if (matchesOriginalAI) {
      setUserHasEdited(false);
      setLocalValue(value);
      setDraft(conversationId, value);
      return;
    }

    if (!userHasEdited) {
      setUserHasEdited(true);
    }

    setLocalValue(value);
    setDraft(conversationId, value);
  };

  const handleSend = () => {
    if (!localValue.trim() || isSendingMessage || !conversation) return;

    const messageToSend = localValue.trim();

    // Treat suggestion as inactive when forceNoAI=true
    const originalSuggestion =
      !forceNoAI && aiSuggestion?.suggestion ? aiSuggestion.suggestion : "";

    let messageSource: MessageSource = "user";
    let matchingPercent: number | undefined;

    if (originalSuggestion) {
      if (normalizeText(originalSuggestion) === normalizeText(messageToSend)) {
        messageSource = "ai";
        matchingPercent = 100;
      } else {
        const similarity = calcSimilarity(originalSuggestion, messageToSend);
        matchingPercent = similarity;
        messageSource = similarity >= 30 ? "edited" : "user";
      }
    }

    // Persist source for bubble rendering (refresh-safe)
    const contentHash = messageToSend.substring(0, 50);
    const messageSourceKey = `msg_source_${conversationId}_${contentHash}`;
    try {
      localStorage.setItem(
        messageSourceKey,
        JSON.stringify({
          source: messageSource,
          timestamp: Date.now(),
          content: messageToSend,
        })
      );
    } catch {}

    sendMessage({
      conversationExternalId: conversation.externalConversationId,
      message: messageToSend,
      messageMatchingSuggestionPercent:
        typeof matchingPercent === "number"
          ? Math.round(matchingPercent)
          : matchingPercent,
    });

    setLocalValue("");
    setUserHasEdited(false);
    lastSuggestionIdRef.current = null;
    setDraft(conversationId, "");

    // Make current/old suggestion inactive after sending anything
    setForceNoAI(true);

    // Track the last sent suggestion ID to prevent echo from clearing forceNoAI
    if (aiSuggestion?.id) {
      lastSentSuggestionIdRef.current = aiSuggestion.id;
    }

    // Prevent auto-population after any send
    justSentMessageRef.current = true;
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handleRestoreAISuggestion = () => {
    const originalSuggestion =
      !forceNoAI && aiSuggestion?.suggestion ? aiSuggestion.suggestion : "";
    if (originalSuggestion) {
      setLocalValue(originalSuggestion);
      setDraft(conversationId, originalSuggestion);
      setUserHasEdited(false);
    }
  };

  const handleNoAIClick = () => {
    setShowNoAITooltip(true);
  };

  // Label source preview (AI Reply / User Modified / User Reply)
  const sourcePreview = useMemo(() => {
    if (!localValue.trim()) return null;

    const originalSuggestion =
      !forceNoAI && aiSuggestion?.suggestion ? aiSuggestion.suggestion : "";

    // No active AI suggestion => always User Reply
    if (!originalSuggestion) return { source: "user" as MessageSource };

    if (
      isShowingAISuggestion ||
      normalizeText(originalSuggestion) === normalizeText(localValue)
    ) {
      return { source: "ai" as MessageSource, similarity: 100 };
    }

    const similarity = calcSimilarity(originalSuggestion, localValue);

    return {
      source: (similarity >= 30 ? "edited" : "user") as MessageSource,
      similarity,
    };
  }, [localValue, aiSuggestion, forceNoAI, isShowingAISuggestion]);

  const sourceLabel =
    sourcePreview?.source === "ai"
      ? "AI Reply"
      : sourcePreview?.source === "edited"
      ? "User Modified"
      : sourcePreview?.source === "user"
      ? "User Reply"
      : null;

  // Measure label width => indent first line only
  useLayoutEffect(() => {
    const wrap = labelWrapRef.current;
    if (!wrap) return;

    const setIndent = () => {
      const labelEl = labelRef.current;
      const w = labelEl ? Math.ceil(labelEl.getBoundingClientRect().width) : 0;
      wrap.style.setProperty("--label-indent", `${w}px`);
    };

    setIndent();

    let ro: ResizeObserver | null = null;
    if (typeof ResizeObserver !== "undefined" && labelRef.current) {
      ro = new ResizeObserver(() => setIndent());
      ro.observe(labelRef.current);
    }

    window.addEventListener("resize", setIndent);
    return () => {
      window.removeEventListener("resize", setIndent);
      ro?.disconnect();
    };
  }, [sourceLabel]);

  const getTooltipStyle = () => {
    const baseStyle: React.CSSProperties = {
      position: "absolute",
      left: "50%",
      zIndex: 0, // Behind the white input container
    };

    switch (tooltipAnimationState) {
      case "hidden":
        return {
          ...baseStyle,
          opacity: 0,
          transform: "translateX(-50%) translateY(0px)",
          pointerEvents: "none",
          transition: "none",
        };
      case "moving-up":
        return {
          ...baseStyle,
          opacity: 1,
          transform: "translateX(-50%) translateY(-60px)",
          transition: "all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)",
        };
      case "visible":
        return {
          ...baseStyle,
          opacity: 1,
          transform: "translateX(-50%) translateY(-60px)",
          transition: "none",
        };
      case "moving-down":
        return {
          ...baseStyle,
          opacity: 0,
          transform: "translateX(-50%) translateY(0px)",
          transition: "all 0.5s ease-in",
        };
    }
  };

  const hasActiveAiSuggestion = !!aiSuggestion?.suggestion && !forceNoAI;

  return (
    <div ref={composerRef} className="sticky bottom-0 z-20 bg-transparent py-6">
      <div className="flex flex-col gap-2 max-w-[720px] mx-auto px-6 relative">
        {/* Floating tooltip (animated) */}
        {showNoAITooltip && (
          <div
            className="flex items-center justify-center gap-2 px-4 py-2 bg-white border border-gray-100 rounded-full shadow-sm"
            style={getTooltipStyle()}
          >
            <svg
              width="14"
              height="14"
              viewBox="0 0 14 14"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6 3.33333H7.33333V4.66667H6V3.33333ZM6 6H7.33333V10H6V6ZM6.66667 0C2.98667 0 0 2.98667 0 6.66667C0 10.3467 2.98667 13.3333 6.66667 13.3333C10.3467 13.3333 13.3333 10.3467 13.3333 6.66667C13.3333 2.98667 10.3467 0 6.66667 0ZM6.66667 12C3.72667 12 1.33333 9.60667 1.33333 6.66667C1.33333 3.72667 3.72667 1.33333 6.66667 1.33333C9.60667 1.33333 12 3.72667 12 6.66667C12 9.60667 9.60667 12 6.66667 12Z"
                fill="black"
                fillOpacity="0.8"
              />
            </svg>
            <span className="text-xs text-gray-600 font-medium whitespace-nowrap">
              The AI thinks no more replies are required for this conversation
            </span>
          </div>
        )}

        {/* Input Area */}
        <div className="bg-white border border-gray-200 rounded-2xl px-4 py-2 shadow-sm focus-within:border-gray-300 transition-colors flex items-center gap-2 relative z-10">
          {/* Left icon */}
          {!hasActiveAiSuggestion ? (
            <div className="flex items-center flex-shrink-0">
              <button
                onClick={handleNoAIClick}
                className="flex items-center justify-center opacity-50 hover:opacity-70 transition-opacity cursor-pointer"
                type="button"
              >
                <DefaultButtonIcon />
              </button>
            </div>
          ) : (
            <div className="group/ai-button relative flex items-center flex-shrink-0">
              <button
                onClick={handleRestoreAISuggestion}
                className="flex items-center justify-center hover:opacity-70 transition-opacity"
                type="button"
              >
                <AISparklesIcon className="text-black/80" />
              </button>

              {/* Hover Tooltip - Speech bubble style */}
              <div
                className="absolute bottom-full mb-2 left-1/2 -translate-x-1/2 opacity-0 group-hover/ai-button:opacity-100 transition-opacity pointer-events-none z-10"
                style={{
                  filter: "drop-shadow(0px 4px 40px rgba(0, 0, 0, 0.1))",
                }}
              >
                <div className="relative bg-white rounded-2xl px-4 py-2 border border-black/10">
                  <div className="text-xs text-gray-600 whitespace-nowrap">
                    Click the icon for AI reply
                  </div>
                  {/* Speech bubble tail */}
                  <svg
                    className="absolute top-full left-1/2 -translate-x-1/2"
                    width="20"
                    height="8"
                    viewBox="0 0 20 8"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path d="M10 8L0 0H20L10 8Z" fill="white" />
                  </svg>
                </div>
              </div>
            </div>
          )}

          {/* Label INSIDE textarea area */}
          <div ref={labelWrapRef} className="relative flex-1 min-w-0">
            {sourceLabel && (
              <span
                ref={labelRef}
                className="absolute left-0 top-0.5 inline-flex items-center rounded-full bg-black/[0.03] px-2 py-0.5 text-[12px] leading-[18px] text-black/60 whitespace-nowrap pointer-events-none"
              >
                {sourceLabel}
              </span>
            )}

            <textarea
              ref={textareaRef}
              value={localValue}
              onChange={handleChange}
              onKeyDown={handleKeyDown}
              placeholder="Start typing..."
              rows={1}
              style={
                sourceLabel
                  ? ({
                      textIndent: "calc(var(--label-indent, 0px) + 8px)",
                    } as React.CSSProperties)
                  : undefined
              }
              className="w-full resize-none border-none outline-none text-sm leading-[22px] placeholder:text-gray-400 bg-transparent min-h-[24px] max-h-[150px] py-0.5"
            />
          </div>

          {/* Send */}
          <Button
            onClick={handleSend}
            disabled={!localValue.trim() || isSendingMessage}
            className="h-8 w-8 rounded-full p-0 flex items-center justify-center flex-shrink-0"
          >
            {isSendingMessage ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <SendHorizontal className="h-4 w-4" />
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};
